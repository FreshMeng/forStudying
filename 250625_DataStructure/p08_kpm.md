公共前后缀

例：ab c ab，ab是公共前后缀；a c a ，a是公共前后缀

![image-20250717133421346](C:\Users\wenyi_meng\AppData\Roaming\Typora\typora-user-images\image-20250717133421346.png)



A  B  A  C  C  A  B  A  B D

0  1   2  3   4  5  6  7  8  9

i    j         do1                      if                     do2

0   -1      next[0] = -1   T  j==-1              i++,j++    

1   0       next[1] = 0     F d[1]==d[0]     j=next[0]=-1

1  -1                               T j==-1              i++,j++

2  0        next[2] = 0    T d[2]==d[0]     i++,j++

3  1        next[3] = 1    F d[3]==d[1]     j=next[1]=0

3  0                               F d[3]==d[0]     j=next[0]=-1

3  -1                              T j==-1              i++,j++

4  0       next[4] = 0     F d[4]==d[0]     j=next[0]=-1

4  -1                              T j==-1              i++,j++

5  0      next[5] = 0      T d[5]==d[0]    i++,j++

6  1      next[6] = 1      T d[6]==d[1]    i++,j++

7  2      next[7] = 2      T d[7]==d[2]    i++,j++

8  3      next[8] = 3      F d[8]==d[3]    j=next[3]=1

8  1                               T d[8]==d[1]    i++,j++

9  2      next[9] = 2      end

next数组，公共前后缀，可以通过前一个next值推导

i是next数组的下标，j是next数组的值

第一位一定是-1，所以next[0]=-1

推下一位，用str[0:n-1]计算next[n]，当前是否满足公共前后缀，两种情况：

1. 之前没有公共前后缀：说明之前的字符都不能做公共前后缀，那新的前后缀只可能是str[n-1]和str[0]，相等满足，不等不满足
2. 之前有公共前后缀：假设之前的公共前后缀长度是m，那str[0:m-1]和str[n-2-(m-1):n-2]是相同的，新的前后缀可能是str[0:m]和str[(n-1)-m:n-1]，由于之前str[0:m-1]和str[n-2-(m-1):n-2]已经相同，此时只要判断str[m]和str[n-1]是否相同就行，如果相同，公共前后缀增加。__如果不同__，查找str[0:m-1]中是否有其他公共前后缀，因为str[0:m-1]与str[n-2-(m-1):n-2]相同，因此它们的公共前后缀一定能匹配上，若新的前后缀长度是x，那新的前后缀可能是str[0:x]与str[(n-1)-x:n-1]。如何得知x的数值？next数组就是记录公共前后缀的，所以next[m]就是x。接下去如果满足就记录前后缀，不相等就找下一层前后缀，直到没有前后缀的情况，也就是第1点。







kmp算法中getNext函数，按步执行结果

从左往右执行，i,j变化时换行，next时next数组，d是简化的s->data数组

字符串 A  B  A  C  C  A  B  A  B D

索引     0  1   2  3   4  5  6  7  8  9

i    j         运行1               判断             结果          运行2

0   -1      next[0]=-1       j==-1                T           i++,j++    

1   0       next[1]=0       d[1]==d[0]         F           j=next[0]=-1

1  -1                              j==-1                T           i++,j++

2  0        next[2]=0       d[2]==d[0]         T           i++,j++

3  1        next[3]=1       d[3]==d[1]         F           j=next[1]=0

3  0                              d[3]==d[0]         F           j=next[0]=-1

3  -1                               j==-1              T            i++,j++

4  0       next[4]=0        d[4]==d[0]         F           j=next[0]=-1

4  -1                               j==-1              T            i++,j++

5  0      next[5]=0         d[5]==d[0]         T           i++,j++

6  1      next[6]=1         d[6]==d[1]         T           i++,j++

7  2      next[7]=2         d[7]==d[2]         T           i++,j++

8  3      next[8]=3         d[8]==d[3]         F           j=next[3]=1

8  1                              d[8]==d[1]         T           i++,j++

9  2      next[9]=2         end

next数组，公共前后缀，可以通过前一个next值推导

i是next数组的下标，j是next数组的值

第一位一定是-1，所以next[0]=-1

通过前一位推下一位，用str[0:n-1]计算next[n]，也就是在已知前面字符串前后缀的基础上，看有没有新前后缀产生，两种情况：

1. 之前没有公共前后缀(j==0)：说明之前的字符都不能做公共前后缀，那新的前后缀只可能是str[n-1]和str[0]。相等是新的前后缀，即前后缀加一位(j++)。不相等那就是没有新的前后缀，执行后j=0。
2. 之前有公共前后缀：算next[n]，找str[0:n-1]的前后缀，假设str[0:n-2]的**前后缀长度是m**，那str[0:m-1]和str[n-2-(m-1):n-2]是相同的，新的前后缀可能是str[0:m]和str[(n-1)-m:n-1]，只要判断str[m]和str[n-1]是否相同就行，如果相同，公共前后缀增加(j++)。

- **如果不同**，查找str[0:m-1]中是否有其他公共前后缀，同时也是str[n-2-(m-1):n-2]的前后缀，也就是第一层前后缀不能产生新的前后缀，看有没有第二层前后缀能用，如果没有，回到情况1；**如果有**，若第二层**前后缀长度是x**，新前后缀可能是str[0:x]与str[(n-1)-x:n-1]。如果相同前后缀+1，不相等就找下一层前后缀，直到情况1。如何得知x的数值？next数组就是记录前后缀的，所以x=next[m]。用变量j表示**前后缀长度**，也就是代码j=next[j]。